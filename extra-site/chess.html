<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Chess — Silika Extras</title>
  <link rel="stylesheet" href="../style.css">
  <style>
    .chess-container { max-width: 520px; margin: 40px auto; text-align: center; }
    .board { display: grid; grid-template-columns: repeat(8, 60px); gap: 0; margin: 0 auto; border: 4px solid #111; }
    .square { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; cursor: pointer; user-select: none; position: relative; }
    .square.light { background: #f0d9b5; }
    .square.dark { background: #b58863; }
    .square.highlight { outline: 3px solid rgba(0,255,204,0.6); }
    .piece { width: 56px; height: 56px; object-fit: contain; pointer-events: none; }
    .piece.moving { animation: movePiece 0.5s ease-in-out forwards; }
    @keyframes movePiece { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: translate(0, 0) scale(1); } }
    .promotion-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; border: 2px solid #00ffcc; border-radius: 8px; padding: 20px; z-index: 1000; box-shadow: 0 0 20px rgba(0,255,204,0.5); }
    .promotion-modal.active { display: block; }
    .promotion-modal h3 { color: #00ffcc; margin-bottom: 15px; }
    .promotion-choices { display: grid; grid-template-columns: repeat(4, 60px); gap: 10px; }
    .promotion-choice { width: 60px; height: 60px; border: 2px solid #333; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; background: #1a1a1a; transition: all 0.3s ease; }
    .promotion-choice:hover { border-color: #00ffcc; background: #222; }
    .promotion-choice img { width: 50px; height: 50px; object-fit: contain; }
    .controls { margin-top: 16px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .controls button { padding: 8px 16px; background: #00ffcc; color: #0f0f0f; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s ease; }
    .controls button:hover { background: #00e5b8; transform: translateY(-2px); }
    .controls button:active { transform: translateY(0); }
    .moves { margin-top: 18px; max-width: 520px; margin-left: auto; margin-right: auto; text-align: left; padding: 8px 12px; background: #111; border-radius: 8px; color: #eaeaea; max-height: 150px; overflow-y: auto; }
    .status { margin-top: 10px; color: #00ffcc; font-weight: bold; }
    @media (max-width: 520px) { .board { transform: scale(0.9); transform-origin: top center; } }
  </style>
</head>
<body>
  <header>
    <nav>
      <h1>Silika — Chess</h1>
      <div>
        <a href="../index.html">Main Site</a>
        <a href="index.html">Extras</a>
      </div>
    </nav>
  </header>

  <div class="chess-container">
    <div id="board" class="board" aria-label="Chess board"></div>

    <div class="controls">
      <button id="btnNew">New Game</button>
      <button id="btnUndo">Undo</button>
      <button id="btnFlip">Flip Board</button>
    </div>

    <div class="status" id="status">Starting game...</div>
    <div class="moves" id="moves"></div>
  </div>

  <!-- Pawn Promotion Modal -->
  <div class="promotion-modal" id="promotionModal">
    <h3>Choose Promotion</h3>
    <div class="promotion-choices" id="promotionChoices"></div>
  </div>

  <script>
    // Self-contained Chess Game Engine (NO EXTERNAL LIBRARY NEEDED)
    class ChessGame {
      constructor() {
        this.board = this.initBoard();
        this.moveHistory = [];
        this.turn = 'white';
        this.selectedSquare = null;
        this.legalMoves = [];
        this.enPassantSquare = null; // Track en passant capture square
        this.castlingRights = {
          white: { k: true, q: true },
          black: { k: true, q: true }
        };
      }

      initBoard() {
        const board = Array(8).fill(null).map(() => Array(8).fill(null));
        // Set up pawns
        for (let i = 0; i < 8; i++) {
          board[1][i] = { type: 'pawn', color: 'black' };
          board[6][i] = { type: 'pawn', color: 'white' };
        }
        // Set up back rows
        const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for (let i = 0; i < 8; i++) {
          board[0][i] = { type: backRow[i], color: 'black' };
          board[7][i] = { type: backRow[i], color: 'white' };
        }
        return board;
      }

      getPiece(row, col) {
        if (row < 0 || row > 7 || col < 0 || col > 7) return null;
        return this.board[row][col];
      }

      getMovesForPiece(row, col) {
        const piece = this.getPiece(row, col);
        if (!piece || piece.color !== this.turn) return [];

        let moves = [];
        const { type } = piece;

        if (type === 'pawn') moves = this.getPawnMoves(row, col);
        else if (type === 'knight') moves = this.getKnightMoves(row, col);
        else if (type === 'bishop') moves = this.getBishopMoves(row, col);
        else if (type === 'rook') moves = this.getRookMoves(row, col);
        else if (type === 'queen') moves = this.getQueenMoves(row, col);
        else if (type === 'king') moves = this.getKingMoves(row, col);

        // Filter out moves that leave king in check
        return moves.filter(([newRow, newCol]) => !this.leavesKingInCheck(row, col, newRow, newCol));
      }

      getPawnMoves(row, col) {
        const moves = [];
        const piece = this.getPiece(row, col);
        const direction = piece.color === 'white' ? -1 : 1;
        const startRow = piece.color === 'white' ? 6 : 1;

        // Forward move
        if (this.getPiece(row + direction, col) === null) {
          moves.push([row + direction, col]);
          // Double move from start
          if (row === startRow && this.getPiece(row + 2 * direction, col) === null) {
            moves.push([row + 2 * direction, col]);
          }
        }

        // Captures
        for (let dcol of [-1, 1]) {
          const newCol = col + dcol;
          const target = this.getPiece(row + direction, newCol);
          if (target && target.color !== piece.color) {
            moves.push([row + direction, newCol]);
          }
        }

        // En Passant
        if (this.enPassantSquare) {
          const [epRow, epCol] = this.enPassantSquare;
          for (let dcol of [-1, 1]) {
            const newCol = col + dcol;
            if (newCol === epCol && row + direction === epRow) {
              moves.push([row + direction, newCol]);
            }
          }
        }

        return moves;
      }

      getKnightMoves(row, col) {
        const moves = [];
        const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for (let [dr, dc] of deltas) {
          const nr = row + dr, nc = col + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const target = this.getPiece(nr, nc);
            if (!target || target.color !== this.getPiece(row, col).color) {
              moves.push([nr, nc]);
            }
          }
        }
        return moves;
      }

      getBishopMoves(row, col) {
        const moves = [];
        for (let [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = row + dr * i, nc = col + dc * i;
            if (nr < 0 || nr > 7 || nc < 0 || nc > 7) break;
            const target = this.getPiece(nr, nc);
            if (!target) {
              moves.push([nr, nc]);
            } else {
              if (target.color !== this.getPiece(row, col).color) moves.push([nr, nc]);
              break;
            }
          }
        }
        return moves;
      }

      getRookMoves(row, col) {
        const moves = [];
        for (let [dr, dc] of [[0,1],[0,-1],[1,0],[-1,0]]) {
          for (let i = 1; i < 8; i++) {
            const nr = row + dr * i, nc = col + dc * i;
            if (nr < 0 || nr > 7 || nc < 0 || nc > 7) break;
            const target = this.getPiece(nr, nc);
            if (!target) {
              moves.push([nr, nc]);
            } else {
              if (target.color !== this.getPiece(row, col).color) moves.push([nr, nc]);
              break;
            }
          }
        }
        return moves;
      }

      getQueenMoves(row, col) {
        return [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
      }

      getKingMoves(row, col) {
        const moves = [];
        const piece = this.getPiece(row, col);
        
        // Regular king moves
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = row + dr, nc = col + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
              const target = this.getPiece(nr, nc);
              if (!target || target.color !== piece.color) {
                moves.push([nr, nc]);
              }
            }
          }
        }

        // Castling
        if (!this.isInCheck(piece.color)) {
          const backRow = piece.color === 'white' ? 7 : 0;
          const rights = this.castlingRights[piece.color];
          
          // Kingside castling
          if (rights.k && this.getPiece(backRow, 7)?.type === 'rook') {
            if (!this.getPiece(backRow, 5) && !this.getPiece(backRow, 6) &&
                !this.isSquareAttacked(backRow, 5, piece.color) &&
                !this.isSquareAttacked(backRow, 6, piece.color)) {
              moves.push([backRow, 6]);
            }
          }
          
          // Queenside castling
          if (rights.q && this.getPiece(backRow, 0)?.type === 'rook') {
            if (!this.getPiece(backRow, 1) && !this.getPiece(backRow, 2) && !this.getPiece(backRow, 3) &&
                !this.isSquareAttacked(backRow, 2, piece.color) &&
                !this.isSquareAttacked(backRow, 3, piece.color)) {
              moves.push([backRow, 2]);
            }
          }
        }

        return moves;
      }

      leavesKingInCheck(fromRow, fromCol, toRow, toCol) {
        const piece = this.board[fromRow][fromCol];
        const captured = this.board[toRow][toCol];
        
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;
        
        const kingPos = this.findKing(piece.color);
        const inCheck = this.isSquareAttacked(kingPos[0], kingPos[1], piece.color);
        
        this.board[fromRow][fromCol] = piece;
        this.board[toRow][toCol] = captured;
        
        return inCheck;
      }

      findKing(color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = this.board[r][c];
            if (p && p.type === 'king' && p.color === color) return [r, c];
          }
        }
        return null;
      }

      isSquareAttacked(row, col, defendingColor) {
        const attackingColor = defendingColor === 'white' ? 'black' : 'white';
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = this.board[r][c];
            if (p && p.color === attackingColor) {
              const moves = this.getAttackMoves(r, c, p.type);
              if (moves.some(([mr, mc]) => mr === row && mc === col)) return true;
            }
          }
        }
        return false;
      }

      getAttackMoves(row, col, type) {
        const moves = [];
        if (type === 'pawn') {
          const dir = this.board[row][col].color === 'white' ? -1 : 1;
          for (let dc of [-1, 1]) {
            const nr = row + dir, nc = col + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) moves.push([nr, nc]);
          }
        } else if (type === 'knight') {
          const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          for (let [dr, dc] of deltas) {
            const nr = row + dr, nc = col + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) moves.push([nr, nc]);
          }
        } else if (type === 'bishop') return this.getBishopMoves(row, col);
        else if (type === 'rook') return this.getRookMoves(row, col);
        else if (type === 'queen') return this.getQueenMoves(row, col);
        else if (type === 'king') {
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = row + dr, nc = col + dc;
              if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) moves.push([nr, nc]);
            }
          }
        }
        return moves;
      }

      makeMove(fromRow, fromCol, toRow, toCol, promotion = 'queen') {
        const piece = this.board[fromRow][fromCol];
        if (!piece) return null;

        const capturedPiece = this.board[toRow][toCol];
        let moveData = {
          piece: piece.type,
          from: [fromRow, fromCol],
          to: [toRow, toCol],
          captured: capturedPiece,
          turn: this.turn,
          castling: false,
          enPassant: false,
          promotion: null
        };

        // Handle en passant
        if (piece.type === 'pawn' && this.enPassantSquare && toRow === this.enPassantSquare[0] && toCol === this.enPassantSquare[1]) {
          const capturedPawnRow = fromRow;
          moveData.captured = this.board[capturedPawnRow][toCol];
          this.board[capturedPawnRow][toCol] = null;
          moveData.enPassant = true;
        }

        // Handle castling
        if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
          moveData.castling = true;
          if (toCol === 6) { // Kingside
            const rook = this.board[fromRow][7];
            this.board[fromRow][5] = rook;
            this.board[fromRow][7] = null;
          } else if (toCol === 2) { // Queenside
            const rook = this.board[fromRow][0];
            this.board[fromRow][3] = rook;
            this.board[fromRow][0] = null;
          }
        }

        // Handle pawn promotion
        if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
          moveData.promotion = promotion;
          piece.type = promotion;
        }

        // Move the piece
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;

        // Update castling rights
        if (piece.type === 'king' || (piece.type === 'rook' && this.castlingRights[piece.color])) {
          if (piece.color === 'white') {
            this.castlingRights.white.k = this.castlingRights.white.q = false;
          } else {
            this.castlingRights.black.k = this.castlingRights.black.q = false;
          }
        }
        if (fromRow === 7 && fromCol === 7) this.castlingRights.white.k = false;
        if (fromRow === 7 && fromCol === 0) this.castlingRights.white.q = false;
        if (fromRow === 0 && fromCol === 7) this.castlingRights.black.k = false;
        if (fromRow === 0 && fromCol === 0) this.castlingRights.black.q = false;

        // Handle en passant for next move
        if (piece.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
          this.enPassantSquare = [(fromRow + toRow) / 2, toCol];
        } else {
          this.enPassantSquare = null;
        }

        this.moveHistory.push(moveData);
        this.turn = this.turn === 'white' ? 'black' : 'white';
        return moveData;
      }

      undo() {
        if (this.moveHistory.length === 0) return false;
        const move = this.moveHistory.pop();
        
        // Restore piece type if promotion happened
        if (move.promotion) {
          this.board[move.from[0]][move.from[1]] = { type: 'pawn', color: move.turn };
        } else {
          this.board[move.from[0]][move.from[1]] = this.board[move.to[0]][move.to[1]];
        }

        // Handle en passant undo
        if (move.enPassant) {
          this.board[move.to[0]][move.to[1]] = null;
          this.board[move.from[0]][move.to[1]] = move.captured;
        } else if (move.castling) {
          const rook = this.board[move.to[0]][move.to[1] === 6 ? 5 : 3];
          this.board[move.to[0]][move.to[1]] = null;
          if (move.to[1] === 6) {
            this.board[move.from[0]][7] = rook;
            this.board[move.from[0]][5] = null;
          } else {
            this.board[move.from[0]][0] = rook;
            this.board[move.from[0]][3] = null;
          }
        } else {
          this.board[move.to[0]][move.to[1]] = move.captured;
        }

        this.turn = move.turn;
        this.enPassantSquare = null;
        return true;
      }

      isInCheck(color) {
        const kingPos = this.findKing(color);
        return this.isSquareAttacked(kingPos[0], kingPos[1], color);
      }

      isCheckmate(color) {
        if (!this.isInCheck(color)) return false;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (this.board[r][c]?.color === color && this.getMovesForPiece(r, c).length > 0) {
              return false;
            }
          }
        }
        return true;
      }

      hasLegalMoves(color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (this.board[r][c]?.color === color && this.getMovesForPiece(r, c).length > 0) {
              return true;
            }
          }
        }
        return false;
      }
    }

    // UI Controller
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const movesEl = document.getElementById('moves');
    const btnNew = document.getElementById('btnNew');
    const btnUndo = document.getElementById('btnUndo');
    const btnFlip = document.getElementById('btnFlip');
    const promotionModal = document.getElementById('promotionModal');
    const promotionChoices = document.getElementById('promotionChoices');

    let game = new ChessGame();
    let flipped = false;
    let pendingPromotion = null;

    function getPieceImage(piece) {
      if (!piece) return null;
      return `./pieces-basic-png/${piece.color}-${piece.type}.png`;
    }

    function rowColToNotation(row, col) {
      return String.fromCharCode(97 + col) + (8 - row);
    }

    function render() {
      boardEl.innerHTML = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const displayR = flipped ? 7 - r : r;
          const displayC = flipped ? 7 - c : c;
          const piece = game.board[displayR][displayC];

          const sq = document.createElement('div');
          sq.className = `square ${((displayR + displayC) % 2 === 0) ? 'light' : 'dark'}`;
          sq.dataset.row = displayR;
          sq.dataset.col = displayC;

          if (game.selectedSquare && game.selectedSquare[0] === displayR && game.selectedSquare[1] === displayC) {
            sq.classList.add('highlight');
          }

          if (game.legalMoves.some(([mr, mc]) => mr === displayR && mc === displayC)) {
            sq.classList.add('highlight');
          }

          if (piece) {
            const img = document.createElement('img');
            img.src = getPieceImage(piece);
            img.className = 'piece';
            img.alt = `${piece.color} ${piece.type}`;
            sq.appendChild(img);
          }

          sq.addEventListener('click', () => onSquareClick(displayR, displayC));
          boardEl.appendChild(sq);
        }
      }

      updateStatus();
      updateMoveLog();
    }

    function onSquareClick(row, col) {
      if (pendingPromotion) return; // Block clicks during promotion

      if (game.selectedSquare && game.selectedSquare[0] === row && game.selectedSquare[1] === col) {
        game.selectedSquare = null;
        game.legalMoves = [];
        render();
        return;
      }

      if (game.selectedSquare) {
        if (game.legalMoves.some(([mr, mc]) => mr === row && mc === col)) {
          const fromPiece = game.getPiece(game.selectedSquare[0], game.selectedSquare[1]);
          
          // Check if pawn promotion
          if (fromPiece.type === 'pawn' && (row === 0 || row === 7)) {
            pendingPromotion = { from: game.selectedSquare, to: [row, col] };
            showPromotionModal();
            return;
          }

          // Make move with animation
          const moveFrom = game.selectedSquare;
          const moveTo = [row, col];
          animateMove(moveFrom, moveTo, () => {
            game.makeMove(moveFrom[0], moveFrom[1], moveTo[0], moveTo[1]);
            game.selectedSquare = null;
            game.legalMoves = [];
            render();
          });
          return;
        }
      }

      const piece = game.getPiece(row, col);
      if (piece && piece.color === game.turn) {
        game.selectedSquare = [row, col];
        game.legalMoves = game.getMovesForPiece(row, col);
        render();
      }
    }

    function showPromotionModal() {
      promotionChoices.innerHTML = '';
      const pieces = ['queen', 'rook', 'bishop', 'knight'];
      const color = game.turn;

      pieces.forEach(piece => {
        const div = document.createElement('div');
        div.className = 'promotion-choice';
        const img = document.createElement('img');
        img.src = `./pieces-basic-png/${color}-${piece}.png`;
        img.alt = piece;
        div.appendChild(img);
        
        div.addEventListener('click', () => {
          const move = pendingPromotion;
          promotionModal.classList.remove('active');
          game.makeMove(move.from[0], move.from[1], move.to[0], move.to[1], piece);
          game.selectedSquare = null;
          game.legalMoves = [];
          pendingPromotion = null;
          render();
        });

        promotionChoices.appendChild(div);
      });

      promotionModal.classList.add('active');
    }

    function animateMove(from, to, callback) {
      const fromEl = boardEl.children[from[0] * 8 + from[1]];
      const toEl = boardEl.children[to[0] * 8 + to[1]];
      
      if (fromEl && fromEl.querySelector('.piece')) {
        const piece = fromEl.querySelector('.piece');
        piece.style.transition = 'all 0.5s ease-in-out';
        
        const fromRect = fromEl.getBoundingClientRect();
        const toRect = toEl.getBoundingClientRect();
        const dx = toRect.left - fromRect.left;
        const dy = toRect.top - fromRect.top;
        
        piece.style.transform = `translate(${dx}px, ${dy}px) scale(1.1)`;
        
        setTimeout(() => {
          piece.style.transition = 'none';
          piece.style.transform = '';
          callback();
        }, 500);
      } else {
        callback();
      }
    }

    function updateStatus() {
      if (game.isCheckmate(game.turn)) {
        const winner = game.turn === 'white' ? 'Black' : 'White';
        statusEl.textContent = `Checkmate! ${winner} wins!`;
      } else if (!game.hasLegalMoves(game.turn)) {
        statusEl.textContent = 'Stalemate - Draw!';
      } else if (game.isInCheck(game.turn)) {
        statusEl.textContent = `${game.turn.charAt(0).toUpperCase() + game.turn.slice(1)} is in Check`;
      } else {
        statusEl.textContent = `${game.turn.charAt(0).toUpperCase() + game.turn.slice(1)}'s Turn`;
      }
    }

    function updateMoveLog() {
      if (game.moveHistory.length === 0) {
        movesEl.textContent = 'No moves yet.';
        return;
      }
      let html = '';
      for (let i = 0; i < game.moveHistory.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const move1 = game.moveHistory[i];
        const move2 = game.moveHistory[i + 1];

        const m1NotFrom = rowColToNotation(move1.from[0], move1.from[1]);
        const m1NotTo = rowColToNotation(move1.to[0], move1.to[1]);
        
        let m1Str = '';
        if (move1.castling) {
          m1Str = move1.to[1] === 6 ? 'O-O' : 'O-O-O'; // Kingside or Queenside
        } else {
          m1Str = `${m1NotFrom}→${m1NotTo}`;
          if (move1.enPassant) m1Str += ' e.p.';
          if (move1.promotion) m1Str += `=${move1.promotion[0].toUpperCase()}`;
        }

        let m2Str = '';
        if (move2) {
          const m2NotFrom = rowColToNotation(move2.from[0], move2.from[1]);
          const m2NotTo = rowColToNotation(move2.to[0], move2.to[1]);
          
          if (move2.castling) {
            m2Str = ` ${move2.to[1] === 6 ? 'O-O' : 'O-O-O'}`;
          } else {
            m2Str = ` ${m2NotFrom}→${m2NotTo}`;
            if (move2.enPassant) m2Str += ' e.p.';
            if (move2.promotion) m2Str += `=${move2.promotion[0].toUpperCase()}`;
          }
        }

        html += `<div><strong>${moveNum}.</strong> ${m1Str}${m2Str}</div>`;
      }
      movesEl.innerHTML = html;
    }

    btnNew.addEventListener('click', () => {
      game = new ChessGame();
      render();
    });

    btnUndo.addEventListener('click', () => {
      if (game.undo()) {
        game.selectedSquare = null;
        game.legalMoves = [];
        render();
      }
    });

    btnFlip.addEventListener('click', () => {
      flipped = !flipped;
      render();
    });

    render();
  </script>
</body>
</html>